blueprint:
  name: Vibration Sensor Filter
  description: >
    Filters reading from a vibration sensor to detect when a vibrating appliance (like a washing machine or dryer) stops running.
    Before configuring this blueprint, mount the vibration sensor on the appliance for a few varying running cycles (for example a
    few different laundry programs in a washing machine). You will need to gather some data to tune the filter.
  domain: automation
  input:
    vibration_sensor:
      name: Vibration Sensor
      description: Binary vibration sensor mounted on the appliance.
      selector:
        entity:
          filter:
            - domain: binary_sensor
              device_class: vibration
          multiple: false
    stop_delay:
      name: Started-to-Stopped transition threshold
      description: >
        For how long continuously, vibrations MUST NOT have been detecteded for the appliance to reliably be considered **Stopped**.
        To tune this, identify the longest vibration-free gap within a running cycle in the vibration sensor's history, and make sure this threshold exceeds that.

        This also marks the delay from when a cycle finishes, until the appliance can been determined as Stopped, so you don't wan't this to be any longer than necessary.
      selector:
        duration:
      default:
        hours: 0
        minutes: 5
        seconds: 0
    start_delay:
      name: Stopped-to-Started transition threshold
      description: >
        For how long continuously, conditions for the Started-to-Stopped threshold MUST NOT have been fulfilled for the appliance to reliably be considered **Started**.

        To tune this, identify the following from the running cycles in the vibration sensor's history:

        - The length of the shortest cycle from the first vibrations to the last vibrations. In the case of a washing machine, this could for example be a 35 minute wool/handwash program.

        - The maximum length of any vibration-triggering conditions that do not mark a cycle, for example unloading a washing machine.


        This value should be shorter than the longest cycle, but longer than the maximum length of any non-cycle related vibrations PLUS the *Started-to-Stopped transition threshold*.
      selector:
        duration:
      default:
        hours: 0
        minutes: 10
        seconds: 0
    running_state_helper:
      name: Started/Stopped State Helper (input_boolean)
      description: >
        *Toggle* helper to store the **Started**/**Stopped** state of the appliance.
        Keep in mind that this cannot necessarily be used to reliably represent the running state of the appliance in real-time.
        Its state will lag behind, and be shorter than the actual state of the appliance.
      selector:
        entity:
          filter:
            - domain: input_boolean
          multiple: false
    started_timer_helper:
      name: >
        Started Timer Helper
      description: Timer helper to determine the **Started** state of the appliance. Create a timer helper first.
      selector:
        entity:
          filter:
            - domain: timer
          multiple: false
    stopped_timer_helper:
      name: >
        Stopped Timer Helper
      description: Timer helper to determine the **Stopped** state of the appliance. Create a timer helper first.
      selector:
        entity:
          filter:
            - domain: timer
          multiple: false

variables:
  started_timer_id: !input started_timer_helper
  stopped_timer_id: !input stopped_timer_helper

mode: single
max_exceeded: silent

triggers:
  - trigger: state
    entity_id: !input vibration_sensor
    to: ["on", "off"]
  - trigger: event
    event_type: timer.finished
    event_data:
      entity_id: !input started_timer_helper
  - trigger: event
    event_type: timer.finished
    event_data:
      entity_id: !input stopped_timer_helper

condition: []

actions:
  - choose:
      # Started timer finished: Switch the running state to Started
      - conditions:
          - condition: template
            value_template: "{{ trigger.event is defined and trigger.event.data.entity_id == started_timer_id }}"
        sequence:
          - action: input_boolean.turn_on
            target:
              entity_id: !input running_state_helper
          - stop: 'Appliance state set to Started, "started" timer finished.'

      # Stopped timer finished: Cancel any running Started timer and switch the running state to Stopped
      - conditions:
          - condition: template
            value_template: "{{ trigger.event is defined and trigger.event.data.entity_id == stopped_timer_id }}"
        sequence:
          - action: timer.cancel
            target:
              entity_id: !input started_timer_helper
          - action: input_boolean.turn_off
            target:
              entity_id: !input running_state_helper
          - stop: 'Appliance state set to OFF, "off" timer finished.'

      # Vibration detected -> Cancel any running Stopped timer and start a Started timer
      - conditions:
          - condition: state
            entity_id: !input vibration_sensor
            state: "on"
        sequence:
          - action: timer.cancel
            target:
              entity_id: !input stopped_timer_helper
          - if:
              - condition: state
                entity_id: !input started_timer_helper
                state: "idle"
              - condition: state
                entity_id: !input running_state_helper
                state: "off"
            then:
              - action: timer.start
                target:
                  entity_id: !input started_timer_helper
                data:
                  duration: !input start_delay

      # Vibration sensor idle: Start a Stopped timer
      - conditions:
          - condition: state
            entity_id: !input vibration_sensor
            state: "off"
        sequence:
          - action: timer.start
            target:
              entity_id: !input stopped_timer_helper
            data:
              duration: !input stop_delay
